#!/bin/sh
#
# logcabin        Startup script for logcabin
#
# chkconfig: - 85 15
# processname: logcabind
# config: /etc/logcabin/logcabin.conf
# config: /etc/sysconfig/logcabin
# pidfile: /var/run/logcabin.pid
# description: logcabin is clustered consensus deamon
#
### BEGIN INIT INFO
# Provides: logcabin
# Required-Start: $local_fs $remote_fs $network
# Required-Stop: $local_fs $remote_fs $network
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: start and stop logcabin
### END INIT INFO

SYSTEMCTL_SKIP_REDIRECT=1

# Source function library.
. /etc/rc.d/init.d/functions


# OVERRIDE REDHAT PROVIDED STATUS FUNCTIONS TO ACCEPT BINARY NAME
# __proc_pids {program} [pidfile]
# Set $pid to pids from /var/run* for {program}.  $pid should be declared
# local in the caller.
# Returns LSB exit code for the 'status' action.
__pids_var_run() {
    local base=${1##*/}
    local pid_file=${2:-/var/run/$base.pid}
    local binary=$3

    pid=
    if [ -f "$pid_file" ] ; then
	local line p

	[ ! -r "$pid_file" ] && return 4 # "user had insufficient privilege"
	while : ; do
	    read line
	    [ -z "$line" ] && break
	    for p in $line ; do
		if [ -z "${p//[0-9]/}" ] && [ -d "/proc/$p" ]; then
		    if [ -n "$binary" ]; then
			local b=$(readlink /proc/$p/exe | sed -e 's/\s*(deleted)$//')
			[ "$b" != "$binary" ] && continue
		    fi
		    pid="$pid $p"
                fi
	    done
	done < "$pid_file"

	if [ -n "$pid" ]; then
	    return 0
	fi
	return 1 # "Program is dead and /var/run pid file exists"
    fi
    return 3 # "Program is not running"
}

status() {
    local base pid lock_file= pid_file= binary=

    # Test syntax.
    if [ "$#" = 0 ] ; then
	echo $"Usage: status [-p pidfile [-b binary]] {program}"
	return 1
    fi
    if [ "$1" = "-p" ]; then
	pid_file=$2
	shift 2
    fi
    if [ "$1" = "-b" ]; then
	if [ -z $pid_file ]; then
	    echo $"-b option can be used only with -p"
	    echo $"Usage: status -p pidfile -b binary program"
	    return 1
	fi
	binary=$2
	shift 2
    fi
    if [ "$1" = "-l" ]; then
	lock_file=$2
	shift 2
    fi
    base=${1##*/}

    if [ "$_use_systemctl" = "1" ]; then
	systemctl status ${0##*/}.service
	ret=$?
	# LSB daemons that dies abnormally in systemd looks alive in systemd's eyes due to RemainAfterExit=yes
	# lets adjust the reality a little bit
	if systemctl show -p ActiveState ${0##*/}.service | grep -q '=active$' && \
		systemctl show -p SubState ${0##*/}.service | grep -q '=exited$' ; then
	    ret=3
	fi
	return $ret
    fi

    # First try "pidof"
    __pids_var_run "$1" "$pid_file" "$binary"
    RC=$?
    if [ -z "$pid_file" -a -z "$pid" ]; then
	pid="$(__pids_pidof "$1")"
    fi
    if [ -n "$pid" ]; then
	echo $"${base} (pid $pid) is running..."
	return 0
    fi

    case "$RC" in
	0)
	    echo $"${base} (pid $pid) is running..."
	    return 0
	    ;;
	1)
	    echo $"${base} dead but pid file exists"
	    return 1
	    ;;
	4)
	    echo $"${base} status unknown due to insufficient privileges."
	    return 4
	    ;;
    esac
    if [ -z "${lock_file}" ]; then
	lock_file=${base}
    fi
    # See if /var/lock/subsys/${lock_file} exists
    if [ -f /var/lock/subsys/${lock_file} ]; then
	echo $"${base} dead but subsys locked"
	return 2
    fi
    echo $"${base} is stopped"
    return 3
}
# END REDHAT FUNCTION OVERRIDE

prog=logcabin
logcabin=${LOGCABIN-/usr/bin/logcabind}
conffile=${CONFFILE-/etc/logcabin.conf}
lockfile=${LOCKFILE-/var/lock/subsys/logcabin}
logfile=${LOGFILE-/var/log/logcabin/logcabin.log}
pidfile=${PIDFILE-/var/run/logcabin.pid}
DAEMON_COREFILE_LIMIT='unlimited'
RETVAL=0

start() {
    echo -n $"Starting $prog: "
    touch ${pidfile}
    chown logcabin ${pidfile}
    daemon --user logcabin ${logcabin} --daemon --config ${conffile} --log ${logfile} --pidfile ${pidfile}
    RETVAL=$?
    echo
    [ $RETVAL = 0 ] && touch ${lockfile}
    return $RETVAL
}

stop() {
    echo -n $"Stopping $prog: "
    killproc -p ${pidfile} ${prog}
    RETVAL=$?
    echo
    [ $RETVAL = 0 ] && rm -f ${lockfile} ${pidfile}
}

configtest() {
    ${logcabin} -t -c ${conffile} $FLAG
    RETVAL=$?
    return $RETVAL
}

rh_status() {
    status -p ${pidfile} -b ${logcabin} ${logcabin}
}

# See how we were called.
case "$1" in
    bootstrap)
        runuser -s /bin/bash logcabin -c "$logcabin --bootstrap --config ${conffile} --log ${logfile}"
        ;;
    start)
        rh_status >/dev/null 2>&1 && exit 0
        start
        ;;
    stop)
        stop
        ;;
    status)
        rh_status
        RETVAL=$?
        ;;
    restart)
        configtest || exit $RETVAL
        stop
        start
        ;;
    condrestart|try-restart)
        if rh_status >/dev/null 2>&1; then
            stop
            start
        fi
        ;;
    configtest)
        configtest
        ;;
    *)
        echo $"Usage: $prog {bootstrap|start|stop|restart|condrestart|try-restart|status|help|configtest}"
        RETVAL=2
esac

exit $RETVAL
